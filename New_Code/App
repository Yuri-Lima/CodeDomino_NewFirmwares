/*

   Criar botÃ£o reset diretamente da placa arduino, sempre que houver necessidade de parar a execuÃ§Ã£o do codigo.
   Nova roda 3D https://www.thingiverse.com/thing:862438/files

*/
int x = 0;
#define botao_gravar_parar 709
#define m_erro 0.03
int r_360= 2050;//2100 passo para 360° da roda
//Dados da Roda C=2*Pi*r
#define raioRoda  3.30 //Raio da roda
float C = (2 * PI * raioRoda);
//Dados do Centro do Eixo Rotação levando referencia o centro do Carro C=2*Pi*r
#define raioEixo  4.5 //Raio do Eixo central do carro. (360° em relação ao centro do carro)
float C_ = (2 * PI * raioEixo);
float revol_ = C_ / C;//Nos paramentos originais 1.363~=1.4 ==> 1 voltas e 0.400 (a roda precisa da 1,4 voltas para o carro rodar em seu eixo)
int e_360 = r_360 * (revol_ + m_erro);//passo para rotação do proprio eixo

unsigned long millisAnterior = 0;
unsigned long millisAtual = 0;
unsigned long millisAnterior2 = 0;
unsigned long millisAtual2 = 0;
long timerBotao = 0;

int valorBotao = 0;
bool ultimoEstadoBotoes = LOW;
int ultimoValorBotoes = 0;
long timerLongoPressionar = 1000;
int latchPin = 8; //Pin connected to ST_CP of 74HC595
int clockPin = 7; //Pin connected to SH_CP of 74HC595
int dataPin = 6; ////Pin connected to DS of 74HC595
int frenagem = 20; //milissegundos entre cada instruÃ§Ã£o de movimento.
int passo = 50; //milissegundos entre cada instruÃ§Ã£o de movimento.
int setDistanciaBasica = 10; //distancia bÃ¡sica de movimento do robÃ´ em linha reta
int passosCaminhar = 0;
bool caminhando = false; //define se o robÃ´ estÃ¡ em movimento ou nÃ£o
byte binarioDir = B00000000;
byte binarioEsq = B00000000;

bool botao = false;
float angle = 0;
int **m;

void setup()
{
   //revol_=  r_360 / revol_; //descubro quanto é 90° 
  Serial.begin(9600);
  Serial.println(e_360);
  pinMode(latchPin, OUTPUT);
  pinMode(clockPin, OUTPUT);
  pinMode(dataPin, OUTPUT);
  digitalWrite(latchPin, LOW);
  shiftOut(dataPin, clockPin, MSBFIRST, B00000000); //envia resultado binÃ¡rio para o shift register
}

void loop()
{
  millisAtual = millis();
  //A cada tempo do passo, execute
  if (millisAtual - millisAnterior >= passo)
  {
    millisAnterior = millisAtual;
    if (botao)
    { 

      formas(0);
      botao = !botao;
      //Serial.println(revol_);
    }
  }

  millisAtual2 = millis();
  if (millisAtual2 - millisAnterior2 >= 300)
  {
    millisAnterior2 = millisAtual2;
    leBotao();
  }
}

//Ref.: https://youtu.be/g2Tco_v73Pc ---> AlocaÃ§Ã£o dinamica
int** alocarMatriz(int Linhas,int Colunas){ //Recebe a quantidade de Linhas e Colunas como ParÃ¢metro
 
  int i,j; //VariÃ¡veis Auxiliares
 
  int **m = (int**)malloc(Linhas * sizeof(int*)); //Aloca um Vetor de Ponteiros
   if(m==NULL)
    {
        Serial.println("Erro de alocacao em linha");
        return 0;
    }
    for (i = 0; i < Linhas; i++)//Percorre as linhas do Vetor de Ponteiros
    {  
        m[i] = (int*) malloc(Colunas * sizeof(int)); //Aloca um Vetor de Inteiros para cada posiÃ§Ã£o do Vetor de Ponteiros.
        if(m[i]==NULL)
        {
            Serial.println("Erro de alicacao em coluna");
            return 0;
        }
        for (j = 0; j < Colunas; j++)//Percorre o Vetor de Inteiros atual.
        { 
            m[i][j] = 0; //Inicializa com 0.
        }
    }
return m; //Retorna o Ponteiro para a Matriz Alocada
}

void desalocarMatriz(int **m, int Linhas)
{
    int i;
    for (i = 0; i < Linhas; i++)
    {
        free(m[i]);
    }
    free(m);
}
int formas(int edro)
{   
   // int p = convertAngulo(45);
   switch(edro)
   {
       case 0: //Circulo em 90°
            m = alocarMatriz(1,edro+1);
            m[0][0] = 0; m[0][1] = 1; m[0][2] = long(e_360); //linha 1Âª comando
            caminhar(m[0][0], m[0][1],  m[0][2], 0, 1);
            Serial.print(m[0][0]);Serial.print(" - ");Serial.print (m[0][1]);Serial.print(" - ");Serial.println(m[0][2]);
            delay(10);
            desalocarMatriz(m,1);
        break;
        case 1: //Reta em 
            m = alocarMatriz(1,edro);
            m[0][0] = 0; m[0][1] = 0; m[0][2] = 2050; //linha 1Âª comando
            caminhar(m[0][0], m[0][1],  m[0][2], 0, NULL);
            Serial.print(m[0][0]);Serial.print(" - ");Serial.print (m[1][1]);Serial.print(" - ");Serial.println(m[2][2]);
            delay(10);
            desalocarMatriz(m,1);
        break;
       case 3://Triangulo em 45°
            
            m = alocarMatriz(6,edro);//6 linhas e 3 colunas
            m[0][0] = 1; m[0][1] = 0; m[0][2] = (long(r_360) * long(45)) / long(360); //linha 1Âª comando
            m[1][0] = 0; m[1][1] = 0; m[1][2] = (long(r_360) * long(10)) / long(C); //linha 2Âª comando
            m[2][0] = 0; m[2][1] = 1; m[2][2] = (long(r_360) * long(90)) / long(360); //linha 3Âª comando
            m[3][0] = 1; m[3][1] = 1; m[3][2] = (long(r_360) * long(10)) / long(C); //linha 4Âª comando
            m[4][0] = 0; m[4][1] = 1; m[4][2] = (long(r_360) * long(45)) / long(360);  //linha 5Âª comando
            m[5][0] = 0; m[5][1] = 0; m[5][2] = (long(r_360) * long(10)) / long(C);  //linha 6Âª comando
            for(int i = 0;i < edro*2;i++)
            {
                caminhar(m[i][0], m[i][1],  m[i][2], 0, NULL);
                Serial.print(m[i][0]);Serial.print(" - ");Serial.print (m[i][1]);Serial.print(" - ");Serial.println(m[i][2]);
                delay(50);
            }
            desalocarMatriz(m,6);
        break;  
        case 4: //Quadrado 10x10 em 90°
            m = alocarMatriz(2,edro);
            m[0][0] = 0; m[0][1] = 0; m[0][2] = (long(r_360) * long(10)) / long(C);; //linha 1Âª comando
            m[1][0] = 1; m[1][1] = 0; m[1][2] = (long(r_360) * long(90)) / long(360);; //linha 2Âª comando
            for(int i = 0;i < 4;i++)
            {  
                for(int j = 0;j < 2;j++)
                { 
                    caminhar(m[j][0], m[j][1],  m[j][2], 0, NULL);
                    //Serial.print(m[i][j]);Serial.print(" - ");Serial.print (m[i][j+k]);Serial.print(" - ");Serial.println(m[i][j+(k+1)]);
                    delay(50);
                }
            }
            desalocarMatriz(m,2);
        break;
        default :
            Serial.println("Formato invalido.");  
    }
    return 1;    
}
long convertAngulo(int _angulo)
{  
    long _PassoEixo = 2800;//como ref. ponto central do eixo
    return (_PassoEixo * _angulo)/360;
}

int caminhar(int dir, int esq, int passosCaminhar, int _freqRot, int _CW_CCW)
{ //0 - direto, 1 - esquerda, 2 - direita, -1 tras)

  while (passosCaminhar > 0)
  {
    digitalWrite(latchPin, LOW);
    
    if(_freqRot > 1)
    {
        if(_CW_CCW == 1) 
        {
            if((passosCaminhar % _freqRot) == 1) direita(dir); 
        }
        else if(_CW_CCW == 0)
        {
            if((passosCaminhar % _freqRot) == 1) esquerda(dir);
        }
    }
    else
    {
        direita(dir); 
        esquerda(esq);
    }
    shiftOut(dataPin, clockPin, MSBFIRST, binarioEsq | binarioDir ); //envia resultado binÃ¡rio para o shift register
    digitalWrite(latchPin, HIGH);
    if (passosCaminhar > frenagem) //acelera e freia o passo
    {
      passo = round(passo * 0.90); //milissegundos entre cada instruÃ§Ã£o de movimento.
    }
    else
    {
      passo = passo + 1;
    }
    passosCaminhar--;
    delay(5);
    //Serial.println(passosCaminhar);

  }
  caminhando = false;
  passo = 50;
  return passosCaminhar == 0 ? 0 : 1;
}

bool esquerda(int _direcao)
{
    static int passoEsq = 1;
  if (_direcao == 1)
  {
    passoEsq++;
  }
  else
  {
    passoEsq--;
  }

  if (passoEsq > 4) passoEsq = 1;
  if (passoEsq < 1) passoEsq = 4;

  switch (passoEsq)
  {
    case 1:
      binarioEsq = B10010000;//144
      break;

    case 2:
      binarioEsq = B11000000;//192
      break;

    case 3:
      binarioEsq = B01100000;//96
      break;

    case 4:
      binarioEsq = B00110000;//48
      break;
  }
}

bool direita(int _direcao)
{
    static int passoDir = 1; 
  if (_direcao == 1)
  {
    passoDir++;
  }
  else
  {
    passoDir--;
  }

  if (passoDir > 4) passoDir = 1;
  if (passoDir < 1) passoDir = 4;

  switch (passoDir)
  {
    case 4:
      binarioDir = B00001100;//12
      break;

    case 3:
      binarioDir = B00000110;//6
      break;

    case 2:
      binarioDir = B00000011;//3
      break;

    case 1:
      binarioDir = B00001001; //9
      break;
  }
}

void leBotao()
{
  valorBotao = analogRead(A0);
  //Serial.println(valorBotao);
  if ((valorBotao > 100) && (valorBotao < botao_gravar_parar))
  {
    botao = !botao;
    delay(1000);
  }
}